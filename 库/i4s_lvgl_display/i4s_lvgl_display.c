#include "i4s_lvgl_display.h"

#include <stdio.h>
#include <driver/audio_ring_buff.h>
#include <os/mem.h>
#include <os/str.h>
#include <os/os.h>
#include <string.h>
#include <ctype.h>


typedef struct {
	uint8_t *lvgl_font_buff_addr;
	RingBufferContext lvgl_font_rb;
}i4s_lvgl_stru_t;
i4s_lvgl_stru_t i4s_lvgl = {0};


#define CONFIG_LVLG_RING_BUFF_SAFE_INTERVAL 4

_font_push_cb push_cb;
_font_pop_cb pop_cb;

static uint8_t i4s_lvgl_display_inited = 0;

/* NOTE below code is for lvgl */
static int utf8_chonfirm_len(unsigned char c) {
    if ((c & 0x80) == 0x00) {
        return 1;    // ASCII
    } else if ((c & 0xE0) == 0xC0) {
        return 2;    // 110xxxxx
    } else if ((c & 0xF0) == 0xE0) {
        return 3;    // 1110xxxx（中文多为这个）
    } else if ((c & 0xF8) == 0xF0) {
        return 4;    // emoji、特殊符号等
    } else {
    	bk_printf("appear abnormal\r\n");
        return -1;
    }
}

// UTF-8 转 Unicode（只支持 1-4字节合法编码）
static uint32_t utf8_to_unicode(const unsigned char *buf, int len) {
    if (len == 1) {
        return buf[0];
    } else if (len == 2) {
        return ((buf[0] & 0x1F) << 6) | (buf[1] & 0x3F);
    } else if (len == 3) {
        return ((buf[0] & 0x0F) << 12) | ((buf[1] & 0x3F) << 6) | (buf[2] & 0x3F);
    } else if (len == 4) {
        return ((buf[0] & 0x07) << 18) | ((buf[1] & 0x3F) << 12) |
               ((buf[2] & 0x3F) << 6) | (buf[3] & 0x3F);
    }
    return 0xFFFFFFFF;
}

// 判断是否是常见标点符号
static int is_unicode_punctuation(uint32_t code) {
    return
        (code >= 0x0020 && code <= 0x007F && ispunct(code)) ||  // 英文标点
        (code >= 0x3000 && code <= 0x303F) ||  // 中文标点
        (code >= 0xFF00 && code <= 0xFFEF) ||  // 全角标点
        (code >= 0x2000 && code <= 0x206F);    // General Punctuation
}

/* NOTE */
int i4s_lvgl_font_demand(uint8_t *data, uint8_t map[ONCE_NEED_WORDS])
{
	if (!data) {
		return 0;
	}
	memset(data, 0x0, 4*ONCE_NEED_WORDS + 1);

	int ret = 0, i = 0;
	uint8_t return_words = 0; /* real get words */
	uint16_t pos = 0; /* auto add data index */
	uint32_t unicode = 0; /* help check is punctuation or not */

	for (i = 0; i < ONCE_NEED_WORDS; i++) {
		ret = i4s_font_pop_cb(FONT_TYPE_UTF8, data, 1); /* 先取一字符 */
		// bk_printf("get data is %02x\r\n", data[0]);
		if (ret <= 0) {
			i4s_font_clear();
			break;
		}

		/* BUG 记录，这里pos和data都往后移动导致累赘思考  */
		ret = utf8_chonfirm_len((unsigned char)data[0]); /* NOTE 判断是否还需要继续读取字节补全字体 */
		// bk_printf("its len is %d\r\n", ret);
		if (ret <= 0) {
			continue;
		}

		data++;
		i4s_font_pop_cb(FONT_TYPE_UTF8, data, ret - 1); /* 现在 data 中存储的是完整数据 */
		data--;

		unicode = utf8_to_unicode((const unsigned char *)data, ret);
		if (is_unicode_punctuation(unicode)) { // is punctuation mark
	        continue;
	    } else {
	        // Not a punctuation mark, continue to show
			data += ret;
			pos += ret;
			map[i] = ret;
			return_words++;
	    }

	}
	data[pos] = '\0';

	return return_words;
}


/* NOTE up code is for lvgl */


/* 拥有字体数据者 设置 此回调函数 < 0: 表示失败 = 0: 成功 */
static int i4s_set_font_push_callback(_font_push_cb cb)
{
	if (cb) {
		push_cb = cb;
		return 0;
	}
	return -1;
}

/* 需要字体数据者 设置 此回调函数 < 0: 表示失败 = 0: 成功*/
static int i4s_set_font_pop_callback(_font_pop_cb cb)
{
	if (cb) {
		pop_cb = cb;
		return 0;
	}
	return -1;
}

/* 拥有字体数据者 调用此函数 给予数据 */
int i4s_font_push_cb(FONT_TYPE type, uint8_t *data, uint32_t data_len)
{
	int ret = 0;
	if (push_cb) {
		ret = (*push_cb)(type, data, data_len);
	}
	return ret;
}

/* 需要字体数据者 设置 此回调函数 */


int i4s_font_pop_cb(FONT_TYPE type, uint8_t *data, uint32_t data_len)
{
	int ret = 0;
	if (pop_cb) {
		ret = (*pop_cb)(type, data, data_len);
	}
	return ret;
}

int i4s_font_clear(void)
{
	if (i4s_lvgl_display_inited == 1) {
		ring_buffer_clear(&i4s_lvgl.lvgl_font_rb);
		return 0;
	}
	return -1;
}

static void *i4s_lvgl_malloc(uint32_t size)
{
#if I4S_FONT_USE_PSRAM
	return psram_malloc(size);
#else
	return os_malloc(size);
#endif
}

static void i4s_lvgl_free(void *ptr)
{
#if I4S_FONT_USE_PSRAM
	psram_free(ptr);
#else
	os_free(ptr);
#endif
}

static int i4s_font_push_func(FONT_TYPE type, uint8_t *data, uint32_t data_len)
{
	if (i4s_lvgl_display_inited != 1) {
		return -1; /* not init */
	}
	if (!data || data_len <= 0) {
		return -2;
	}

	if (type != FONT_TYPE_UTF8) {
		return -3; /* this lib just save UTF-8 */
	}
	int ret = 0;

	ret = ring_buffer_get_free_size(&i4s_lvgl.lvgl_font_rb);
	if (ret < data_len) {
		return -3; /* free data room is not enough */
	} else {
		ret = ring_buffer_write(&i4s_lvgl.lvgl_font_rb, data, data_len);
	}

	return ret; // conv_utf8
}

static int i4s_font_pop_func(FONT_TYPE type, uint8_t *data, uint32_t data_len)
{
	if (i4s_lvgl_display_inited != 1) {
		return 0; /* not init */
	}
	if (!data || data_len <= 0) {
		return -2;
	}
	if (type != FONT_TYPE_UTF8) {
		return -3; /* this lib just save UTF-8 */
	}
	int ret = 0;

	ret = ring_buffer_get_fill_size(&i4s_lvgl.lvgl_font_rb);
	if (ret < data_len) {
		if (ret > 0)
			data_len = ret;
		else
			return -3;
	}
	ret = ring_buffer_read(&i4s_lvgl.lvgl_font_rb, data, data_len);

	return ret;
}


int i4s_lvgl_display_init(void)
{
	if (i4s_lvgl_display_inited != 0) {
		return 0; /* already init */
	}
	int ret = 0;

	i4s_lvgl_display_inited = 1;

	if (!i4s_lvgl.lvgl_font_buff_addr) {
		i4s_lvgl.lvgl_font_buff_addr = i4s_lvgl_malloc(LVGL_RING_BUFFER_SIZE + CONFIG_LVLG_RING_BUFF_SAFE_INTERVAL);
		if (i4s_lvgl.lvgl_font_buff_addr == NULL) {
			bk_printf("i4s_lvgl_display_init malloc failed\r\n");
			goto exit;
		}
	}

	ring_buffer_init(&i4s_lvgl.lvgl_font_rb, i4s_lvgl.lvgl_font_buff_addr, LVGL_RING_BUFFER_SIZE + CONFIG_LVLG_RING_BUFF_SAFE_INTERVAL, DMA_ID_MAX, RB_DMA_TYPE_NULL);
	
	ret = i4s_set_font_push_callback(i4s_font_push_func);
	if (ret != 0) {
		goto exit;
	}
	ret = i4s_set_font_pop_callback(i4s_font_pop_func);
	if (ret != 0) {
		goto exit;
	}
	
	return 0;
exit:
	i4s_lvgl_display_deinit();

	return -1;
}


int i4s_lvgl_display_deinit(void)
{
	if (i4s_lvgl_display_inited != 1) {
		return 0; /* not init */
	}

	i4s_font_clear();

	if (i4s_lvgl.lvgl_font_buff_addr) {
		i4s_lvgl_free(i4s_lvgl.lvgl_font_buff_addr);
		i4s_lvgl.lvgl_font_buff_addr = NULL;
	}

	push_cb = NULL;
	pop_cb = NULL;

	i4s_lvgl_display_inited = 0;
	return 0;
}



/* test */
/* NOTE 要使用strlen 结尾就必须是 0x00 结尾 否则不可控了 */
uint8_t test_data[] = {0xe6,0xb7,0xb1,0xe5,0x9c,0xb3,0xe5,0xb8,0x82,0xe5,0x9b,0x9b,0xe5,0xad,0xa3,0xe5,0xae,0x8f,0xe8,0x83,0x9c,0xe7,0xa7,0x91,0xe6,0x8a,0x80,0xe6,0x9c,0x89,0xe9,0x99,0x90,0xe5,0x85,0xac,0xe5,0x8f,0xb8,0xe6,0x88,0x90,0xe7,0xab,0x8b,0xe4,0xba,0x8e,0x32,0x30,0x31,0x32,0xe5,0xb9,0xb4,0x36,0xe6,0x9c,0x88,0xef,0xbc,0x8c,0xe6,0x98,0xaf,0xe4,0xb8,0x80,0xe5,0xae,0xb6,0xe4,0xbb,0xa5,0xe6,0x99,0xba,0xe8,0x83,0xbd,0xe5,0xad,0x98,0xe5,0x82,0xa8,0xe8,0xae,0xbe,0xe5,0xa4,0x87,0xe7,0xa0,0x94,0xe5,0x8f,0x91,0xe4,0xb8,0xba,0xe6,0xa0,0xb8,0xe5,0xbf,0x83,0xe7,0x9a,0x84,0xe5,0x9b,0xbd,0xe5,0xae,0xb6,0xe9,0xab,0x98,0xe6,0x96,0xb0,0xe6,0x8a,0x80,0xe6,0x9c,0xaf,0xe4,0xbc,0x81,0xe4,0xb8,0x9a,0xef,0xbc,0x8c,0xe4,0xb8,0x93,0xe6,0xb3,0xa8,0xe4,0xba,0x8e,0xe4,0xb8,0xba,0xe4,0xb8,0xaa,0xe4,0xba,0xba,0xe5,0xae,0xb6,0xe5,0xba,0xad,0xe4,0xb8,0x8e,0x53,0x4f,0x48,0x4f,0xe7,0xba,0xa7,0xe7,0xbd,0x91,0xe7,0xbb,0x9c,0xe6,0x8f,0x90,0xe4,0xbe,0x9b,0xe5,0xad,0x98,0xe5,0x82,0xa8,0xe8,0xae,0xbe,0xe5,0xa4,0x87,0xe5,0xbc,0x80,0xe5,0x8f,0x91,0xe8,0xa7,0xa3,0xe5,0x86,0xb3,0xe6,0x96,0xb9,0xe6,0xa1,0x88,0xe3,0x80,0x82,0xe5,0x85,0xac,0xe5,0x8f,0xb8,0xe4,0xb8,0xbb,0xe5,0xaf,0xbc,0xe4,0xba,0xa7,0xe5,0x93,0x81,0xe5,0x8c,0x85,0xe6,0x8b,0xac,0xe7,0x88,0xb1,0xe5,0x9b,0x9b,0xe5,0xad,0xa3,0xe7,0xb3,0xbb,0xe5,0x88,0x97,0xe6,0x99,0xba,0xe8,0x83,0xbd,0xe7,0xa7,0xbb,0xe5,0x8a,0xa8,0xe5,0x85,0x85,0xe7,0x94,0xb5,0xe5,0xae,0x9d,0xe3,0x80,0x81,0xe6,0x99,0xba,0xe8,0x83,0xbd,0xe7,0xa1,0xac,0xe7,0x9b,0x98,0xe7,0xad,0x89,0xe5,0xb9,0xb6,0xe6,0x8b,0xa5,0xe6,0x9c,0x89,0xe2,0x80,0x9c,0xe8,0x93,0x9d,0xe7,0x89,0x99,0xe6,0x91,0x84,0xe5,0x83,0x8f,0xe5,0xa4,0xb4,0xe7,0x9a,0x84,0xe6,0x8e,0xa7,0xe5,0x88,0xb6,0xe6,0x96,0xb9,0xe6,0xb3,0x95,0xe3,0x80,0x81,0xe8,0xae,0xbe,0xe5,0xa4,0x87,0xe5,0x92,0x8c,0xe5,0x8f,0xaf,0xe8,0xaf,0xbb,0xe5,0xad,0x98,0xe5,0x82,0xa8,0xe4,0xbb,0x8b,0xe8,0xb4,0xa8,0xe2,0x80,0x9d,0xe7,0xad,0x89,0xe5,0xa4,0x9a,0xe9,0xa1,0xb9,0xe4,0xb8,0x93,0xe5,0x88,0xa9,0xe6,0x8a,0x80,0xe6,0x9c,0xaf,0xe3,0x80,0x82,0xe6,0x88,0xaa,0xe8,0x87,0xb3,0x32,0x30,0x32,0x35,0xe5,0xb9,0xb4,0xef,0xbc,0x8c,0xe5,0x85,0xac,0xe5,0x8f,0xb8,0xe6,0xb3,0xa8,0xe5,0x86,0x8c,0xe8,0xb5,0x84,0xe6,0x9c,0xac,0xe4,0xb8,0xba,0x31,0x31,0x33,0x31,0x2e,0x39,0x39,0x37,0x33,0xe4,0xb8,0x87,0xe5,0x85,0x83,0xe4,0xba,0xba,0xe6,0xb0,0x91,0xe5,0xb8,0x81,0xef,0xbc,0x8c,0xe7,0xb4,0xaf,0xe8,0xae,0xa1,0xe5,0xaf,0xb9,0xe5,0xa4,0x96,0xe6,0x8a,0x95,0xe8,0xb5,0x84,0x31,0xe5,0xae,0xb6,0xe4,0xbc,0x81,0xe4,0xb8,0x9a,0xef,0xbc,0x8c,0xe6,0x8c,0x81,0xe6,0x9c,0x89,0x31,0x37,0xe9,0xa1,0xb9,0xe4,0xb8,0x93,0xe5,0x88,0xa9,0xe5,0x8f,0x8a,0x34,0x31,0xe9,0xa1,0xb9,0xe8,0xbd,0xaf,0xe4,0xbb,0xb6,0xe8,0x91,0x97,0xe4,0xbd,0x9c,0xe6,0x9d,0x83,0xe3,0x80,0x82};
int push_test(void) {
	int ret = 0;
	ret = i4s_font_push_cb(FONT_TYPE_UTF8, test_data, sizeof(test_data));
	return ret;
}
