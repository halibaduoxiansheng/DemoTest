18:47 2021/2/1018:48 2021/2/10
 TCP的套接字的socket编程
	TCP是面向连接的可靠的传输协议。利用TCP协议进行通信时，首先要建立通信双方的连接。一旦连接建立完成，就可以进行通信。
	TCP提供了数据确认和数据重传（如果没有接受到时需要重新传的）的机制，保证了发送的数据一定能到达通信的对方。
	基于TCP面向连接的socket编程的服务器端程序流程如下：
（1）创建套接字socket。
（2）将创建的套接字绑定（bind）到本地的地址和端口上。
（3）设置套接字的状态为监听模式（listen），准备接受客户端的连接请求。
（4）接受请求（accept），同时返回得到一个同于连接的新套接字。
（5）使用这个新套接字进行通信（通信函数使用send/recv）.
（6）通信完毕，释放套接字资源（closesocket）。								
	基于TCP面向连接的socket编程的客户端程序流程如下：
（1）创造套接字socket。
（2）向服务器发出连接请求（connect）。
（3）请求连接后与服务器进行通信操作（send/recv）。
（4）释放套接字资源（closesocket）。
在服务器的一端，当调用accept函数时,程序就会进行等待，直到有客户端调用connect函数发送连接请求，然后服务器接受该请求，这样服务器与客户端就建立了连接。当两者
建立连接后就可以进行通信了。
服务器可以说在一旦建立连接后，实际上它已经保存了客户端的IP地址和端口号的信息，因此可以利用返回的套接字进行与客户端的联系。
UDP的套接字的socket编程
 	UDP是无连接的不可靠的传输协议。采用UDP进行通信时，不需要建立连接，可以直接向一个IP地址发送数据，但是不能保证对方能收到。
	对于基于UPD面向无连接的套接字编程来说，服务器端和客户端这种概念不是特别的严格。可以把服务器称为接收端，客户端就会发送数据的发送端。
	基于UDP面向无连接的socket编程的发送端程序流程如下：
（1）创建套接字socket。
（2）将套接字绑定（bind）到一个本地地址和端口上。  ----可以说谁绑定都反过来了
（3）等待接受数据。（recvfrom）
（4）释放套接字资源。
	基于UDP面向无连接的socket编程的接收端程序流程如下：
（1）创建套接字socket。
（2）向服务器发送数据（sendto）。
（3）释放套接字资源（closesocket）。


！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
                                 ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
                                                     ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
                                                                     ！！！！！！！！！！！！！！！！！！！！！！！！！！！！
                                                                                        ！！！！！！！！！！！！！！！
						！！！！！！！！！
						         ！！！！！
						            ！！！
							！




                                                                                                          16.3套接字函数
  16.3.1	套接字函数介绍

	1.WSAStartup 函数（WSAStartup，即WSA(Windows Socket Asynchronous，Windows套接字异步)的启动命令）
	该函数的功能是初始化套接字库。其原型如下：（套接字库就是包含套接字函数的函数库）
	int WSAStrartup(WORD wVersionRequested,LPWSADATA lpWSAData);              (LP全称是(local-preference)（本地路由优先，在bgp路由协议中使用的一个属性）)
    注意：WSAStartup 函数用于初始化 Ws2_32.dll 动态链接库。🔂在使用套接字函数之前，一定要初始化Ws2_32.dll动态链接库。
  1，wVersionRequested:表示调用者使用的Windows Socket的版本，高字节记录修订版本，低字节记录主版本。例如，如果Windows Socket的版本为2.1，则高字节记录1
，低字节记录2。
  2，lpWSAData: 是一个WSADATA结构指针，该结构详细记录了Windows套接字的相关信息。
typedef struct  WSAData
{
WORD		wVersion;	//这个与下面一行一起确定版本类型
WORD		wHighVersion; 	//正如我上一行所说的
char		szDescription[WSADESCRIPTION_LEN+1];                  // Line Equipment Number, 线路设备数目[编号]
char		szSystemStatus[WSASYS_STATUS_LEN+1];	//和上一行一样，用于说明线路
unsigned short        iMaxSockets;			
unsigned short 	iMaxUdpDg;
char FAR*	lpVendorlnfo;
}WSADATA,FAR*LPWSADATA;
//wVersion: 表示调用者使用的WS2_32.DLL动态库的版本号。
//wHighVersion：表示WS2_32.DLL支持的最高版本，通常与wVersion相同。
//szDesciption：表示套接字的描述信息，通常没有实际意义。
//szSystemStatus:表示系统的配置或状态信息，通常没有实际意义。
//iMaxSockets:表示最多可以打开多少个套接字。在套接字版本2或以后的版本中，	该成员将被忽略。
//iMaxUdpDg:表示数据报的最大长度。在套接字版本2或以后的版本中，		该成员将被忽略。
//lpVendorlnfo：表示套接字的厂商信息。在套接字版本2或以后的版本中，	该成员将被忽略。
 例如，使用WSAStrartup初始化套接字，版本为2.2：
WORD wVersionRequested;             /*WORD(字)，类型为unsigned short*/	---------------------基本是默认类型，总是写这个，两个单词开头字母大写
WSADATA wsaData;                        /*库版本信息结构*/                          		----------------------全部大写是数据类型，只大写D就是结构体变量
/*定义版本类型。将两个字节组合成一个字，前面是低字节，后面是高字节*/            
wVersionRequested = MAKEWORD(2.2);      /*表示版本号*/
/*加载套接字库，初始化Ws2_32.dll 动态链接库*/
WSAStartup(wVersionRequested,&wsaData);
             从上面的代码中可以看出，MAKEWORD 宏的作用是：根据给定的两个无符号字节，创建一个16位的无符号整型，将创建的值
赋予wVersionRequested 变量，表示套接字的版本号。

！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
	2.socket函数
	该函数的功能是创建一个套接字。其原型如下：
	SOCKET socket(int af,int type,int protocol);
	af:是一个地址家族，通常为AF_INET.（AF_INET为网际域）	//它说通常看见没！！！
	type：表示套接字类型。如果为SOCK_STREAM,表示创建面向连接的流式套接字:如果为SOCK_DGRAM,----（ 数据报
		 离散可控性和可观性，数据报套接字）表示创建面向无连接的数据报套接字；如果为SOCK_RAW,表示
		创建原始套接字。对于这些值，用户可以在winsock2.h头文件中找到。
	protocol：表示套接字所用的协议，如果用户不指定，可以设置为0(通常情况下，将其设置为0，由系统自动选择合适的协议)。
	返回值：创造的套接字句柄(非负整数)。  失败返回 -1
	例如，使用socket函数创建一个套接字socket_server:
	/*创建套接字*/
	/*AF_INET表示指定地址族，SOCK_STREAM表示流式套接字TCP,特定的地址家族相关的协议*/
	socket_server=socket(AF_INET,SOCK_STREAM,0);
	在代码中，如果socket函数调动成功，它就会返回一个新的SOCKET数据类型的套接字描述符。使用定义好的套接字socket_server进行保存。
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！ ！
	3.bind函数
	（缓冲区(buffer)这个中文译意源自当计算机的高速部件与低速部件通讯时,必须将高速部件的输出暂存到某处,以保证
	    高速部件与低速部件相吻合. 后来这个意思被扩展了,成为"临时存贮区"的意思。）
	    该函数的功能是将套接字绑定到指定的端口和地址上。其原型如下：
	int bind(SOCKET s,const struct sockaddr FAR* name,int namelen);
	s:表示套接字标识。
	name:是一个sockaddr结构指针---------该结构中包含了要结合的 地址 和 端口号。
	namelen:确定name缓冲区的长度。
	返回值:如果函数执行成功，则返回为0，------------否则为SOCKET_ERROR（-1）.
	在创办了套接字之后，应该将该套接字绑定到本地的某个地址和端口上，这时就需要该函数了。例如，使用bind函数绑定一个套接字：
	SOCKADDR_IN Server_add;			/*服务器地址信息结构*/
	Server_add.sin_family=AF_INET;		/*地址家族，必须是AF_INET,注意只有它不是网络字节顺序*/
	Server_add.sin_addr.S_un.S_addr=htonl(INADDR_ANY);/*主机地址*/
	Server_add.sin_port=htons(5000);		/*端口号*/
	bind(socket_server,(SOCKADDR*)&Server_add,sizeof(SOCKADDR));	/*使用bind函数进行绑定*/
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
	4.listen函数
	该函数的功能是将套接字设置成监听模式。--------对于流式套接字，必须处于监听模式才能够接受客户端套接字的连接。
	（监听谁咯，几个人去监听咯）
	该函数的原型如下：
	int listen(SOCKET s,int backlog);
	s:表示套接字标识。
	backlog：标识等待连接的最大队列长度。例如，如果backlog被设置成2，此时有3个客户端同时发出连接请求，那么前两个客户端连接
	会被放置在等待队列中，第三个客户端会得到错误信号。
	例如：使用listen函数设置套接字为监听状态：（只要没有close或服务器进程崩溃关闭 就会一直处于监听状态）
	listen(socket_server,5);
	设置套接字为监听状态，为连接做准备，最大等待的数目为5.
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
	5.accept函数
	该函数的功能是接受客户端的连接。在流式套接字中，只有套接字处于监听状态，才能接受客户端的连接。该函数的原型如下：
SOCKET accept(SOCKET s,struct sockaddr FAR*addr,int FAR*addrlen);
	s:是一个套接字，它应处于监听状态。
	addr：是一个sockaddr_in结构指针，包含一组客户端的端口号、IP地址等信息。
	addrlen：用于接受参数addr的长度。
	返回值：------------------一个新的套接字，它对应于已经接受的客户端的连接，对于该客户端所有的后续操作，都应使用这个新的套接字。
例如：使用accept函数接受客户端的连接请求：
	/*接受客户端的发送请求，等待客户端发送connect请求*/
	socket_receive=accept(socket_server,(SOCKADDR*)&Client_add,&Length);
	其中，socket_receive保存接受请求后返回的新的套接字，socket_server为绑定在地址和端口上的套接字，而Client_add是有关客户端
	IP地址和端口的信息结构，最后的Length是Client_add的大小。可以使用sizeof函数取得，然后用Length变量保存。
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
	6.closesocket函数
	该函数的功能是关闭套接字。其原型如下：
	int closesocket(SOCKET s);
	其中，s标识一个套接字。如果参数s设置了SO_DONTLINGER选项，则调用该函数后会立即返回。此时如果有数据尚未传输完毕，
	则会继续传输数据，然后再关闭套接字。
	例如：使用closesocket函数关闭套接字，释放客户端的套接字资源。
	closesocket(socket_receive);
	在代码中，socket_receive是一个套接字，当不使用时就可以利用closesocket函数将其资源释放。
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
	7.connect函数
	该函数的功能是发送一个连接请求。其原型如下：
	int connect(SOCKET s,const struct sockaddr FAR* name,int namelen);
	s:表示一个套接字。
	name：表示套接字s要连接的主机地址和端口号。
	namelen：是name缓冲区的长度------（一般都是使用sizeof函数）。
	返回值：如果函数执行成功，则返回值为0，否则为SOCKET_ERROR。用户可以通过WSAGETLASTERROR得到错误描述。
	例如，使用connect函数与一个套接字建立连接。
	connect(socket_send,(SOCKADDR*)&Server_add,sizeof(SOCKADDR));
	在代码中，socket_send表示要与服务器建立连接的套接字，而Server_add是要连接的服务器地址信息。
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
	8.htons函数--------------（host-to-network-for type 'short'）
	该函数的功能是将一个16位的无符号短整型数据由主机排列方式转换为网络排列方式。其原型如下：
	u_short htons(u_short hostshort);
	hostshort:是一个主机排列方式的无符号短整型数据。
	返回值：函数返回值为16位的网络排列方式数据。
	例如：使用htons函数对一个无符号短整型数据进行转换：
	Server_add.sin_port=htons(5000);
	在代码中，Server_add是有关主机地址和端口的结构，其中sin.port表示的是端口号。因为端口号要使用的网络排列方式，所以需要使用htons函数进行转换，从而设定端口号。
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
	9.htonl函数-------（host-to-network-for type 'long'）
	该函数的功能是将一个无符号长整型数据由主机排列方式转换为网络排列方式·。其原型如下：
 u_long htonl(u_long hostlong);
	hostlong:表示一个主机排列方式的无符号长整型数据。
	返回值：32位的网络排列方式数据。
	其使用方式与htons函数相似，不过是将一个32位数据转换为TCP/IP网络字节顺序。
-----网络排列方式
	10.inet_addr函数
	该函数的功能是将一个有字符串表示的地址转换为32的无符号长整型数据。其原型如下：
	unsigned long inet_addr(const char FAR*cp);
	cp:表示一个IP地址的字符串。
	返回值：32位无符号长整型。
	例如：使用inet_addr函数将一个字符串转换成一个以点分十进制格式表示的IP地址（如192.168.1.43）：
	Server_add.sin_addr.S_un.S_addr=inet_addr("192.168.1.43");
	在代码中设置服务器的IP地址为198.168.1.43.
、！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
	11.recv函数
	该函数的功能是从面对连接的套接字中接受数据，一般用于TCP。如原型如下：
	int recv(SOCKET s,char FAR*buf,int len,int flags);
	s:表示一个套接字。
	buf：表示接受数据的缓冲区。
	len：表示buf的长度。
	flags：表示函数的调用方式。-----------------------如果为MSG_PEEK,则表示查看传来的数据，在序列前段的数据会被复制一份到返回缓冲区中，
	但是这个数据不会从序列中移走；如果为MSG_OOB，则表示用来处理Out-Of-Band数据，也就是外带数据。
	返回值：实际copy的字节数。
	例如：使用recv函数接受数据：
	recv(socket_send,Receivebuf,100,0);
	其中，socket_send是用于连接的套接字，而Receivebuf是用来接受保存数据的空间的，100是该空间的大小。
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
	12.send函数
	该函数的功能是在面对连接方式的套接字间发送数据。其原型如下：
	int send(SOCKET s,const char FAR*buf,int len,int flags);
	s:表示一个套接字。
	buf：表示存放要发送的数据的缓冲区。
	len：表示缓冲区长度。
	flags：表示函数的调用方式。
	例如：使用send函数发送数据：
 	send(socket_receive,Sendbuf,100,0);
	在代码中。socket_receive用于连接的套接字，而Sendbuf保存要发送的数据，100为该数据的大小。
	应用层到传输层的数据搬运（只有ack机制才能知道数据是否成功接收）
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
	13.recvfrom函数
	该函数用于接收一个数据报信息并保存源地址。其原型如下：
	int recvfrom(SOCKET s,char FAR*buf,int len,int flags,struct sockaddr FAR*from,int FAR*fromlen);
	s:表示准备接受数据的套接字。
	buf：指向缓冲区的指针，用来接受数据。
	len:表示接受数据缓冲区的长度。（表示能接收到的字节的最大容量，而函数的返回值才是实际接收的字节数）
	flags：通过设置该值可以影响函数的调用行为。（一般写0，表示无限期堵塞，直到接收到数据，连接错误或则关闭）
	from：是一个指向地址结构的指针，用来接受发送数据方的地址信息。
	fromlen：表示地址缓冲区的长度。
	返回值: 表示接受到的数据的字节数（TCP时，如果返回0，代表对方关闭了连接，UDP不可能返回0）
	14.sendto函数
	该函数的功能是向一个特定的目的方发送数据。其原型如下：
	int sendto(SOCKET s,const char FAR*buf,int len,int flags,const struct sockaddr FAR*to,int tolen);
	s:表示一个（可能已经建立连接）套接字的标识符。
	buf：指向缓冲区的指针，该缓冲区包含将要发送的数据。
	len：表示缓冲区的长度。（控制发送数据的长度）
	flags：通过设置该值可以影响函数的调用行为。
	to：指定目标套接字的地址。
	tolen：表示缓冲区的长度。
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
	15.WSACleanup函数
	该函数的功能是释放为Ws2_32.dll动态链接库初始化时分配的资源。其原型如下：
	int WSACleanup(void);
	使用该函数可关闭动态链接库：
	WSACleanup();	/*关闭动态链接库*/
			//可不像free函数，这直接写上去就好了
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
							


！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
select函数
select() 用于监视多个文件描述符是否准备好进行 读写 操作
同时监控多个套接字，可以检测读、写和异常事件, 当没有事件发生时，会堵塞直到有事件发生或超时。
（这里是使用队列存储，遵循队列原则FIFO,先进先出）

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
nfds： 整型值，表示待检测的文件描述符的总数。通常取所有文件描述符集合中最大的文件描述符值加 1（max函数）
readfds： 指向fd_set结构的指针，用来存放待检测的 读事件 的文件描述符。
writefds： 指向fd_set结构的指针，用来存放待检测的 写事件 的文件描述符。
exceptfds： 指向fd_set结构的指针，用来存放待检测的 异常事件 的文件描述符。
timeout： 指向timeval结构的指针，用来设置超时时间。如果为NULL，则select会一直阻塞直到有文件描述符准备好或出错。
（超时或接收到数据后，重新调用select函数，虽然监听不会停止，但是需要监听新的事件就需要重新调用
简单理解：在处理完一件事情后，必须重新调用select函数）
返回值 ==0：超时  <0:出错  >0:有消息 
后面总是使用FD_ISSET是因为select会保留那些有活动的文件描述符